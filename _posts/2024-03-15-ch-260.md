---
title: Uniqe Multisets
topic: Challenge 260
top_link: https://theweeklychallenge.org/blog/perl-weekly-challenge-260
---
# Unique Multisets

## Task 1: Unique Occurrences
**Submitted by:  Mohammad Sajid Anwar**

---
You are given an array of integers, `@ints`.

Write a script to return 1 if the number of occurrences of each value in the given array is unique or 0 otherwise.

### Example 1
```
Input: @ints = (1,2,2,1,1,3)
Output: 1

The number 1 occurred 3 times.
The number 2 occurred 2 times.
The number 3 occurred 1 time.

All occurrences are unique, therefore the output is 1.
```
### Example 2
```
Input: @ints = (1,2,3)
Output: 0
```
### Example 3
```
Input: @ints = (-2,0,1,-2,1,1,0,1,-2,9)
Output: 1
```
---
### Solution

The implementation is straightforward: Count the occurrences of each number and then count the different occurrences.
The count of unique numbers shall be equal to the count of occurrences.
```perl
use v5.24;
use warnings;

sub uniq_occur {
	my %count;
    $count{$_}++ for @_;
    (\my %occur)->@{values %count} = ();

    keys %occur == keys %count;
}

```
See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-260/jo-37/perl/ch-1.pl).

## Task 2: Dictionary Rank
**Submitted by: Mark Anderson**

---
You are given a word, `$word`.

Write a script to compute the dictionary rank of the given word.

### Example 1
```
Input: $word = 'CAT'
Output: 3

All possible combinations of the letters:
CAT, CTA, ATC, TCA, ACT, TAC

Arrange them in alphabetical order:
ACT, ATC, CAT, CTA, TAC, TCA

CAT is the 3rd in the list.
Therefore the dictionary rank of CAT is 3.
```
### Example 2
```
Input: $word = 'GOOGLE'
Output: 88
```
### Example 3
```
Input: $word = 'SECRET'
Output: 255
```
---
### Solution
#### Theoretical Analysis
The background of this task are permutations of multisets.
The description from Wikipedia for a [**multiset**](https://en.wikipedia.org/wiki/Multiset):
> In mathematics, a **multiset** (or **bag**, or **mset**) is a modification of the concept of a set that, unlike a set, allows for multiple instances for each of its elements. The number of instances given for each element is called the multiplicity of that element in the multiset.

and for [**permutations of multisets**](https://en.wikipedia.org/wiki/Permutation#Permutations_of_multisets):
> If $$M$$ is a finite multiset, then a **multiset permutation** is an ordered arrangement of elements of $$M$$ in which each element appears a number of times equal exactly to its multiplicity in $$M$$. An anagram of a word having some repeated letters is an example of a multiset permutation. If the multiplicities of the elements of $$M$$ (taken in some order) are $$m_{1}, m_{2}, ..., m_{l}$$ and their sum (that is, the size of $$M$$) is $$n$$, then the number of multiset permutations of $$M$$ is given by the **multinomial coefficient**,
>  
$$
{n \choose m_{1},m_{2},\ldots ,m_{l}}={\frac {n!}{m_{1}!\,m_{2}!\,\cdots \,m_{l}!}}={\frac {\left(\sum_{i=1}^{l}{m_{i}}\right)!}{\prod_{i=1}^{l}{m_{i}!}}}
$$

However, this task does not ask for the total number of multiset permutations (*mperm*s), but for the position of a given mperm in the lexicographical ordered list of all mperms.
In the following we assume a multiset $$M$$ having elements $$(1, 2, ...,l)$$ with multiplicities
$$m_{1}, m_{2}, ..., m_{l}$$.

Let us denote

$$\mathcal{M}(M) :=  {n \choose m_{1},m_{2},\ldots ,m_{l}}$$

as the number of mperms for the multiset $$M$$ and

$$\mathcal{R}(p, M)$$

as the rank of the mperm $$p$$ in the multiset $$M$$, i.e. the number of preceding elements.

Obviously, $$\mathcal{R}((m), \{m\}) = 0$$, as there is only one permutation of a singleton.

Let <span>$$n = |M| > 1$$</span> and $$p = (p_1, ...,p_n)$$ an mperm of $$M$$

For every $$m^* \in M, m^* < p_1$$ and every mperm $$p^* = (p_2^*, ..., p_n^*)$$ of $$M \setminus \{m\}$$
we can see that $$(m^*, p^*) \prec p$$ as these start with a smaller element than $$p$$.
The number of mperms that can be formed from the remaining elements is known by its multinomial coefficient.

Thus the number of mperms of $$M$$ starting with an element less than $$p_1$$ is

$$\sum_{m^* < p_1} \mathcal{M}(M \setminus \{m^*\})$$

The remaining mperms of $$M$$ that precede $$p$$ must all start with $$p_1$$ and their number is

$$\mathcal{R}((p_2,...,p_n), M \setminus \{p_1\})$$

which gives a recursive formula for the rank of $$p$$.

The time complexity of this approach is polynomial in contrast to the exponential effort of an enumeration of mperms.
See some examples in the full solution using long words.
#### Implementation

A mperm may be represented as an array `@p` of its elements in their order.
Analogous to the representation of (sub-)sets as a bit vector indicating the existence of elements, a submultiset may be represented as an array `@m` of the elements multiplicities.

Given these representations, the implementation of the above formula is straightforward.

- count the multiplicity of every character in `$word`
- sort the pairs (character, multiplicity) ascending by character
- map each unique character in `$word` to an index from `0 .. l`
- convert `$word` to a mperm of the indices `0 .. l`
- convert `$word` to a mset represented by the array of multiplicities

The latter two give the starting point to the rank calculation as described in the previous section.

Finally a tail-call optimization can be performed: The next recursion level may overwrite the current context.
For this purpose the subroutine arguments are given by reference and are modified in place.

The calculated rank is zero-based and needs to be adjusted for the given task.
```perl
use v5.24;
use warnings;
use bigint;
use Math::Prime::Util qw(vecsum vecprod factorial);
use List::AllUtils qw(sort_by count_by pairs);
use experimental qw(refaliasing signatures);

sub dictionary_rank {
    my @chars = split //, shift;
    my @freq = sort_by {$_->[0]} pairs count_by {$_} @chars;
    my $i = 0;
    my %chartoidx = map +($_->[0], $i++), @freq;
    my @mperm = map $chartoidx{$_}, @chars;
    my @mset = map $_->[1], @freq;
    
    multipermtonum(my $rank = 0, \@mperm, \@mset);
}

sub multipermtonum ($, $perm, $set) {
    \my $num = \$_[0];
    my $first = shift @$perm;
    return $num unless @$perm;

    for my $p (grep $set->[$_], 0 .. $first - 1) {
        my @set = ($set->@*);
        $set[$p]--;
        $num += factorial(vecsum @set) / vecprod map factorial($_), @set;
    }
    $set->[$first]--;
    goto &multipermtonum;
}

```
See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-260/jo-37/perl/ch-2.pl).
