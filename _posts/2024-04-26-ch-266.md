---
title: Uncommon Shapes
topic: Challenge 266
top_link: https://theweeklychallenge.org/blog/perl-weekly-challenge-266
---
# {{ page.title }}
## Task 1: Uncommon Words
**Submitted by: Mohammad Sajid Anwar**

---
You are given two sentences, `$line1` and `$line2`.

Write a script to find all uncommmon words in any order in the given two sentences. Return `('')` if none found.

> A word is uncommon if it appears exactly once in one of the sentences and doesnâ€™t appear in other sentence.

### Example 1
```
Input: $line1 = 'Mango is sweet'
       $line2 = 'Mango is sour'
Output: ('sweet', 'sour')
```
### Example 2
```
Input: $line1 = 'Mango Mango'
       $line2 = 'Orange'
Output: ('Orange')
```
### Example 3
```
Input: $line1 = 'Mango is Mango'
       $line2 = 'Orange is Orange'
Output: ('')
```
---
### Solution
The definition of an *uncommon word* has an interesting aspect:
It is actually independent from any *sentence* structure.

> A word is uncommon, if and only if it appears exactly once in the flattened list of words.

Thus we may throw away the sentence structure completely and just look at the words as a single list and follow the usual "counting items" procedure.
Applying a case sensitive word compare as suggested by the examples.

A little bit more tricky is the case without uncommon words, where not an *empty list* shall be returned but a *list containing an empty string*.
Here we need to buffer the result in an array because any Boolean operation on a list or array forces these into scalar context, hiding the original content.

```perl
use strict;
use warnings;

sub uncommon_words {
    my %words;
    $words{$_}++ for split /[^[:alpha:]]+/, "@_";

    my @ucw = grep $words{$_} == 1, keys %words;

    (@ucw, ('') x !@ucw);
}
```
See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-266/jo-37/perl/ch-1.pl).
## Task 2: X Matrix
**Submitted by: Mohammad Sajid Anwar**

---
You are given a square matrix, `$matrix`.

Write a script to find if the given matrix is X Matrix.

> A square matrix is an X Matrix if all the elements on the main diagonal and antidiagonal are non-zero and everything else are zero.

### Example 1
```
Input: $matrix = [ [1, 0, 0, 2],
                   [0, 3, 4, 0],
                   [0, 5, 6, 0],
                   [7, 0, 0, 1],
                 ]
Output: true
```
### Example 2
```
Input: $matrix = [ [1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9],
                 ]
Output: false
```
### Example 3
```
Input: $matrix = [ [1, 0, 2],
                   [0, 3, 0],
                   [4, 0, 5],
                 ]
Output: true
```
---
### Solution
With `PDL`, this task can be solved in a few simple steps:

- Create an X-shaped mask matrix `$x` by setting the diagonal and antidiagonal elements to one and all other elements to zero.
- Pick the two sets of elements from `$matrix` where the mask is set resp. not set.
- Check that all masked values are non-zero and all other values are zero.

Here is a demonstration for example 1 in the pdl-shell:
```
pdl> do_print 1
1
pdl> $matrix = pdl [ [1, 0, 0, 2],
                     [0, 3, 4, 0],
                     [0, 5, 6, 0],
                     [7, 0, 0, 1],
                   ]

[
 [1 0 0 2]
 [0 3 4 0]
 [0 5 6 0]
 [7 0 0 1]
]

pdl> $x = zeroes $matrix

[
 [0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]
]

pdl> $x->diagonal(0, 1) .= 1
[1 1 1 1]
pdl> $x(-1:0)->diagonal(0, 1) .= 1
[1 1 1 1]
pdl> $x

[
 [1 0 0 1]
 [0 1 1 0]
 [0 1 1 0]
 [1 0 0 1]
]

pdl> $matrix->where_both($x)
$PDL1 = [1 2 3 4 5 6 7 1];
$PDL2 = [0 0 0 0 0 0 0 0];
```
The final check is self-explanatory.

```perl
use strict;
use warnings;
use PDL;
use PDL::NiceSlice;

sub is_x {
    my $m = pdl @_;
    my $x = zeroes $m;
    $x->diagonal(0, 1) .= 1;
    $x(-1:0)->diagonal(0, 1) .= 1;
    my ($on_x, $off_x) = $m->where_both($x);

    all($on_x) && !any($off_x);
}
```

See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-266/jo-37/perl/ch-2.pl).
