---
title: Average Progression
challenge: 351
---
<h2 id="task-1">
Task 1: Special Average
</h2>
**Submitted by: Mohammad Sajid Anwar**

---
You are given an array of integers.

Write a script to return the average excluding the minimum and maximum of the given array.
### Example 1
```
Input: @ints = (8000, 5000, 6000, 2000, 3000, 7000)
Output: 5250

Min: 2000
Max: 8000
Avg: (3000+5000+6000+7000)/4 = 21000/4 = 5250
```
### Example 2
```
Input: @ints = (100_000, 80_000, 110_000, 90_000)
Output: 95_000

Min: 80_000
Max: 110_000
Avg: (100_000 + 90_000)/2 = 190_000/2 = 95_000
```
### Example 3
```
Input: @ints = (2500, 2500, 2500, 2500)
Output: 0

Min: 2500
Max: 2500
Avg: 0
```
### Example 4
```
Input: @ints = (2000)
Output: 0

Min: 2000
Max: 2000
Avg: 0
```
### Example 5
```
Input: @ints = (1000, 2000, 3000, 4000, 5000, 6000)
Output: 3500

Min: 1000
Max: 6000
Avg: (2000 + 3000 + 4000 + 5000)/4 = 14000/4 = 3500
```
---
### Solution
Find the minimum and the maximum value from the list and take the arithmetic average over all elements that are distinct from the extrema.
#### Perl
The solution using `PDL` is straightforward.
```perl
use strict;
use warnings;
use PDL;

sub special_average {
    my $i = long @_;
    $i->where(!$i->in(long($i->minmax)))->avg;
}
```
See the [full solution]({{ page.solution_url }}/challenge-{{ page.challenge }}/jo-37/perl/ch-1.pl) to task 1.

#### J
The logic in `J` is identical.

{% raw %}
```
SpecialAvg =: {{(+/ % #) (#~ -.@(e. (<./ , >./))) y}}
NB.              GGGGGG   FF EE  DD  BBB C AAA 
```
{% endraw %}
`A` minimum  
`B` maximum  
`C` join as list (fork B-C-A)  
`D` check if an item is an extremum  
`E` logical negation  
`F` use the indicators for "inner" items as selector into the list (hook F-E...)  
`G` calculate the arithmetic average over the remaining list (fork: sum divided by count)

```
echo SpecialAvg 8000 5000 6000 2000 3000 7000
exit ''
```

See the [full solution]({{ page.solution_url }}/challenge-{{ page.challenge }}/jo-37/j/ch-1.ijs).

<h2 id="task-2">
Task 2: Arithmetic Progression
</h2>
**Submitted by: Mohammad Sajid Anwar**

---
You are given an array of numbers.

Write a script to return true if the given array can be re-arranged to form an arithmetic progression, otherwise return false.

> A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

### Example 1
```
Input: @num = (1, 3, 5, 7, 9)
Output: true

Already AP with common difference 2.
```
### Example 2
```
Input: @num = (9, 1, 7, 5, 3)
Output: true

The given array re-arranged like (1, 3, 5, 7, 9) with common difference 2.
```
### Example 3
```
Input: @num = (1, 2, 4, 8, 16)
Output: false

This is geometric progression and not arithmetic progression.
```
### Example 4
```
Input: @num = (5, -1, 3, 1, -3)
Output: true

The given array re-arranged like (-3, -1, 1, 3, 5) with common difference 2.
```
### Example 5
```
Input: @num = (1.5, 3, 0, 4.5, 6)
Output: true

The given array re-arranged like (0, 1.5, 3, 4.5, 6) with common difference 1.5.
```
---
### Solution
General approach:  
- Pair each value with its position in a sorted list, resulting in a `2xn`-matrix of _points_.
- Take the vector difference between one point and the rest, resulting in a `2x(n-1)`-matrix of _vectors_.
- The values form an _arithmetic progression_ if the _points_ are located on a line i.e the _vectors_ are collinear.
- For the latter, the matrix formed by the vectors must have rank `1`

This approach is like taking a sledgehammer to crack a nut, but this is fun - at least for the sledgehammer.

#### Perl
`PDL` comes with the `mrank` function that can be use here.
When processing floating point numbers, a tolerance needs to be specified.
```perl
use strict;
use warnings;
use PDL;
use PDL::NiceSlice;
use PDL::LinearAlgebra;

sub arith_progression {
    my $n = pdl(\@_, [0]);
    $n($n(,(0))->qsorti,1) .= sequence($n->dim(0));
    1 == mrank $n(1:-1) - $n(0), 1e-6;
}
```

See the [full solution]({{ page.solution_url }}/challenge-{{ page.challenge }}/jo-37/perl/ch-2.pl) to task 2.
#### J
I couldn't find a library function in `J` that calculates the rank of a matrix as simple as in `PDL`.
With a provided `mrank` function, the logic is the same as in `PDL`.

Artificial constraints:
- list elements shall stay in place
- write a wrapper to a library function to calculate the rank of a matrix

{% raw %}
```
ArithProg =: {{1 = mrank (}. -"1 {.) |: (,: ((] i.~ /:~) i.@#)) y}}
NB.            KKK JJJJJ  GG III HH  FF  EE   B DDD CCC  AAAA
```
`A` sequence in length of list  
`B` list itself  
`C` index sort (hook (BD)C-A)  
`D` indices of list elements in sorted list (fork B-D-C)  
`E` join list and indices  
`F` transpose matrix  
`G` tail rows of matrix  
`H` first row of matrix  
`I` diff to first row (fork G-I-H)  
`J` matrix rank from own implementation  
`K` rank shall be `1`

`A` - `D` combine an index sort and a permutation inverse.

The `mrank` function:
```
load 'math/mt'

mrankint =: 3 : 0
    rcond =. >0{y
    rank =. >1{y
    a =. >2{y
    result =. rcond gelpf_mt_ a
    (3 4 {result), 2{y
)

mrank =: 3 : 0
    result =. mrankint^:_ FP_EPS_mt_;0;y
    >1{result
)
```
{% endraw %}
`mrankint`: From a _rank condition_, an ignored rank and the matrix, calculate a new estimate for the _rank condition_,
the respective rank using `gelpf` and pass the matrix unchanged.  
`mrank`: set an initial _rank condition_ and interate `mrankint` until it converges to a fixed _rank condition_ and rank.

Lessons learned in `J`:
- perform an index sort
- calculate the inverse of a permutation
- use libraries / namespaces
- use the _power of a verb_ for a converging loop

See the [full solution]({{ page.solution_url }}/challenge-{{ page.challenge }}/jo-37/j/ch-2.ijs) to task 2.
