---
title: The Greatest Target
topic: Challenge 264
top_link: https://theweeklychallenge.org/blog/perl-weekly-challenge-264
---
# {{ page.title }}
## Task 1: Greatest English Letter
**Submitted by: Mohammad Sajid Anwar**

---
You are given a string, `$str`, made up of only alphabetic characters `[a..zA..Z]`.

Write a script to return the greatest english letter in the given string.

> 
>A letter is greatest if it occurs as lower and upper case. Also letter ‘b’ is greater than ‘a’ if ‘b’ appears after ‘a’ in the English alphabet.
>

### Example 1
```
Input: $str = 'PeRlwEeKLy'
Output: L

There are two letters E and L that appears as lower and upper.
The letter L appears after E, so the L is the greatest english letter.
```
### Example 2
```
Input: $str = 'ChaLlenge'
Output: L
```
### Example 3
```
Input: $str = 'The'
Output: ''
```
---
### Solution
The task may easily generalized to arbitrary strings and can be solved in a single pass through the string.

- Convert the string to its [Normalization Form](https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization) "Canonical Composition".
- Split the string into characters and loop over these.
  * Check the [General Category properties](https://en.wikipedia.org/wiki/Unicode#General_Category_property) "Letter uppercase" and "Letter lowercase" and store a corresponding bit in a hash keyed with the case folded character.
  * If both cases of the character have been found in the string, choose the new maximum character for the next loop.
- Transform the maximum letter found in the loop to upper case.

```perl
use strict;
use warnings;
use Unicode::Normalize;
use List::Util 'reduce';

sub gl {
    my %l;
    uc reduce {
        local $_ = $b;
        my $fc = fc;
        ($l{$fc} |= /\p{Ll}/ | /\p{Lu}/ << 1) == 3 && $fc gt $a ?
            $fc :
            $a;
    } '', split //, NFC shift;
}
```

See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-264/jo-37/perl/ch-1.pl).

## Task 2: Target Array
**Submitted by: Mohammad Sajid Anwar**

---
You are given two arrays of integers, `@source` and `@indices`.
The `@indices` can only contains integers `0 <= i < size of @source`.

Write a script to create target array by insert at index `$indices[i]` the value `$source[i]`.

### Example 1
```
Input: @source  = (0, 1, 2, 3, 4)
       @indices = (0, 1, 2, 2, 1)
Output: (0, 4, 1, 3, 2)

@source  @indices  @target
0        0         (0)
1        1         (0, 1)
2        2         (0, 1, 2)
3        2         (0, 1, 3, 2)
4        1         (0, 4, 1, 3, 2)
```
### Example 2
```
Input: @source  = (1, 2, 3, 4, 0)
       @indices = (0, 1, 2, 3, 0)
Output: (0, 1, 2, 3, 4)

@source  @indices  @target
1        0         (1)
2        1         (1, 2)
3        2         (1, 2, 3)
4        3         (1, 2, 3, 4)
0        0         (0, 1, 2, 3, 4)
```
### Example 3
```
Input: @source  = (1)
       @indices = (0)
Output: (1)
```
---
### Solution
This task has a concealed complexity.
It states

> insert at index `$indices[i]` the value `$source[i]`

without further specifying this insertion process.
So let's look at another example:
```
Input: @source  = (1, 2, 3, 4)
       @indices = (3, 0, 0, 0)

@source  @indices  @target
1        3         (undef, undef, undef, 1)
2        0         (2, undef, undef, 1)
3        0         (3, 2, undef, 1)
4        0         (4, 3, 2, 1)
```
Each time a new value is inserted at index 0, the length of the block that has to be shifted must be determined (unless the element is not defined yet).

In general, following the recipe will thus lead to a complexity of $$\mathcal{O}(n^2)$$.

But we may reverse the view and - instead of inserting items - find the final positions in the first place.

For this end, we first need to define a *valid index*:  
We call an index array $$I = (i_1,\ldots,i_n)$$ *valid*, if it has the same size as the source array
$$S = (s_1,\ldots,s_n)$$ and applying the recipe produces a target array $$T = (t_1,\ldots,t_n)$$ that has items on all positions $$1 \le k \le n$$.

Consider a valid index array $$I$$ and pick a value $$i^*$$ from its elements, which may appear multiple times.

Then find $$c_l$$ and $$c_h$$ as the number of elements in $$I$$ where $$i_k < i^*$$ resp. $$i_k \le i^*$$.
For a *valid index* we can see that all of the $$c_l$$ elements indexed by $$i_k < i^*$$ must be placed in the target array at $$(t_1,\ldots,t_{c_l})$$ to avoid holes.
Analogously the $$n - c_h$$ elements indexed by $$i_k > i^*$$ must be placed at $$(t_{c_h + 1},\ldots,t_n)$$.

Therefore only an insertion at the index $$i^*$$ itself can cause an element at the final positions
$$(t_{c_l + 1},\ldots,t_{c_h})$$ to be set or modified.
More specifically, all items inserted at position $$i^*$$ will appear in reversed order as $$(t_{c_l + 1},\ldots,t_{c_h})$$ in the target.

After these considerations we are able to construct the target *without* shifting:

- For each distinct index, we find the number of smaller indices and hence the starting point in the target array.
- Source items indexed with the same index are placed in reverse order into the target at the starting point.

This can be achieved with a vector sort and some index shuffling.
We sort the list of pairs $$(i_j, j)$$ ascending by $$i_j$$ and descending by $$j$$ and take the resulting column $$(j)$$ as indices into the source array.


The complexity for this approach is $$\mathcal{O}(n \log n)$$

An example, processing the recipe:
```
@source  = (5, 4, 3, 2, 1)
@indices = (3, 0, 0, 0, 3)

@source  @indices  @target
5        3         (undef, undef, undef, 5)
4        0         (4, undef, undef, 5)
3        0         (3, 4, undef, 5)
2        0         (2, 3, 4, 5)
1        3         (2, 3, 4, 1, 5)
```
Tracing the same example in the PDL shell:
```
pdl> do_print 1
1
pdl> $s = pdl 5, 4, 3, 2, 1
[5 4 3 2 1]
pdl> $i = pdl 3, 0, 0, 0, 3
[3 0 0 0 3]
pdl> $p = $i->cat(-sequence $i)->xchg(0, 1)

[
 [ 3  0]
 [ 0 -1]
 [ 0 -2]
 [ 0 -3]
 [ 3 -4]
]

pdl> $c = $p->qsortvec

[
 [ 0 -3]
 [ 0 -2]
 [ 0 -1]
 [ 3 -4]
 [ 3  0]
]

pdl> $ti = -$c((1))
[3 2 1 4 0]
pdl> $s($ti)
[2 3 4 1 5]
```

But what happens to *invalid* index arrays?
From the above considerations we should expect diverging results for the insertion process and our construction.
For  
`@source = (1, 2, 3)`  
some invalid index arrays are  
`@indices = (2, 2, 2)` or  
`@indices = (0, 2, 2)`  
leading to targets  
`(undef, undef, 3, 2, 1)` resp.  
`(1, undef, 3, 2)`.  
Our process leads to  
`(3, 2, 1)` and  
`(1, 3, 2)`  
instead, which is a nice result.

Here is the implementation:
```perl
use strict;
use warnings;
use PDL;
use PDL::NiceSlice;

sub target_array {
    my ($s, $i) = map pdl($_), @_;
    $s(-$i->cat(-sequence($i))->xchg(0, 1)->qsortvec->((1)));
}
```


See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-264/jo-37/perl/ch-2.pl).
