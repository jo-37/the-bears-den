---
title: Bits, Digits and Numbers
topic: Challenge 261
top_link: https://theweeklychallenge.org/blog/perl-weekly-challenge-261
---
# Bits, Digits and Numbers
## Task 1: Element Digit Sum
**Submitted by: Mohammad Sajid Anwar**

---
You are given an array of integers, `@ints`.

Write a script to evaluate the absolute difference between element and digit sum of the given array.

### Example 1
```
Input: @ints = (1,2,3,45)
Output: 36

Element Sum: 1 + 2 + 3 + 45 = 51
Digit Sum: 1 + 2 + 3 + 4 + 5 = 15
Absolute Difference: | 51 - 15 | = 36
```
### Example 2
```
Input: @ints = (1,12,3)
Output: 9

Element Sum: 1 + 12 + 3 = 16
Digit Sum: 1 + 1 + 2 + 3 = 7
Absolute Difference: | 16 - 7 | = 9
```
### Example 3
```
Input: @ints = (1,2,3,4)
Output: 0

Element Sum: 1 + 2 + 3 + 4 = 10
Digit Sum: 1 + 2 + 3 + 4 = 10
Absolute Difference: | 10 - 10 | = 0
```
### Example 4
```
Input: @ints = (236, 416, 336, 350)
Output: 1296
```
---
### Solution
The task will be generalized to an arbitrary base $$b > 1$$.
For any non-negative integer we have

$$
n = \sum_{i=0}^l d_i b^i \ge \sum_{i=0}^l d_i
$$

and thus there is no need to take the absolute value of the difference between a number and the sum of its digits.

Using some functions from [`Math::Prime::Util`](https://metacpan.org/pod/Math::Prime::Util),
the task may be solved in a single statement:
```perl
use strict;
use warnings;
use Math::Prime::Util qw(vecreduce vecsum todigits);

sub eds {
    my $base = shift;
    vecreduce {$a + $b - vecsum todigits $b, $base} 0, @_;
}
```
See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-261/jo-37/perl/ch-1.pl).

## Task 2: Multiply by Two
**Submitted by: Mohammad Sajid Anwar**

---
You are given an array of integers, `@ints` and an integer `$start`.

Write a script to do the followings:

 a) Look for `$start` in the array `@ints`, if found multiply the number by 2  
 b) If not found stop the process otherwise repeat

In the end return the final value.

### Example 1
```
Input: @ints = (5,3,6,1,12) and $start = 3
Output: 24

Step 1: 3 is in the array so 3 x 2 = 6
Step 2: 6 is in the array so 6 x 2 = 12
Step 3: 12 is in the array so 12 x 2 = 24

24 is not found in the array so return 24.
```
### Example 2
```
Input: @ints = (1,2,4,3) and $start = 1
Output: 8

Step 1: 1 is in the array so 1 x 2 = 2
Step 2: 2 is in the array so 2 x 2 = 4
Step 3: 4 is in the array so 4 x 2 = 8

8 is not found in the array so return 8.
```
### Example 3
```
Input: @ints = (5,6,7) and $start = 2
Output: 2

2 is not found in the array so return 2.
```
---
### Solution
There is no need to traverse the list more than once as we know the "interesting" values beforehand:
$$\mathit{start}\,\cdot\,2^i$$.
Actually, we need to know which is the smallest of the "interesting" values that is *missing* from the list.
For this end we define a bit vector of "missing interesting values" that is all-one initially.
With every interesting number we encounter, the corresponding bit will be cleared.
Finally the least significant bit that is set leads to the requested result.

The core of this implementation is a little trick to find the value of the least significant bit from a number $$n$$:

$$\mathit{lsb}(n) = n\,\&\,-n$$

where "$$-n$$" is the negative value of $$n$$ as two's complement and "$$\&$$" is the bitwise AND operation.
Not only can this formula be used to extract the value of the LSB: It can be used to check if a number is a power of two, too.
As the formula operates on signed integers, we need to `use integer` here.
```perl
use strict;
use warnings;
use integer;

sub mb2 {
    my $start = shift;
    my $missing = -1;
    for my $n (@_) {
        next if !$n || $n % $start;
        my $found = $n / $start;
        $missing &= ~$found if $found == ($found & -$found);
    }
    $start * ($missing & -$missing);
}
```

See the [full solution](https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-261/jo-37/perl/ch-2.pl).
